# -*- coding: utf-8 -*-
"""loss_functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JMHUOIUJb6ffDLcNs9AmQLAEwG_enbYJ
"""

# import packages
import numpy as np

# distance-based loss using Manhattan distance

def distance_based_loss(child_pos, parent_pos):
    # Calculate Manhattan distance between child and parent positions
    distance = np.sum(np.abs(child_pos - parent_pos))
    return distance

# distance-based loss using Euclidean distance
def euclidean_distance_loss(child_pos, parent_pos):
    # Calculate Euclidean distance between child and parent positions
    distance = np.sqrt(np.sum((child_pos - parent_pos) ** 2))
    return distance

# step-based loss function
def step_based_loss(child_action, parent_action):
    if child_action == parent_action:
        return 0  # Lower loss for matching actions
    else:
        return 1  # Higher loss for differing actions

# hybrid loss function (considering both distance and step-based loss)
def hybrid_loss(child_pos, parent_pos, child_action, parent_action, alpha, beta):
    # Calculate Euclidean distance loss
    distance_loss = np.sqrt(np.sum((child_pos - parent_pos) ** 2))

    # Calculate step-based loss
    if child_action == parent_action:
        step_loss = 0  # Lower loss for matching actions
    else:
        step_loss = 1  # Higher loss for differing actions

    # Combine distance-based loss and step-based loss with weights
    total_loss = alpha * distance_loss + beta * step_loss

    return total_loss

# we can ignore this


def train_child(maze, parent_path, learning_rate, num_episodes, k):
    num_steps = len(parent_path)
    child_path = []

    for episode in range(num_episodes):
        child_pos = parent_path[0]  # Start child at the same initial position as parent

        for step in range(num_steps):
            child_path.append(child_pos)

            if step < num_steps - 1:
                # Calculate Euclidean distance loss
                loss = euclidean_distance_loss(child_pos, parent_path[step])

                # Get available actions from current position
                available_actions = get_available_actions(maze, child_pos, k)

                # Choose action that minimizes the loss
                best_action = None
                min_loss = float('inf')
                for action in available_actions:
                    next_pos = get_next_position(child_pos, action)
                    next_loss = euclidean_distance_loss(next_pos, parent_path[step + 1])
                    if next_loss < min_loss:
                        min_loss = next_loss
                        best_action = action

                # Update child's position based on chosen action
                child_pos = get_next_position(child_pos, best_action)

        # Reset child's path for the next episode
        child_path = []

    return child_path

def get_available_actions(maze, pos, k):
    actions = []
    if pos[0] > 0 and maze[pos[0] - 1, pos[1]] == 0:  # Up
        actions.append((-1, 0))
    if pos[0] < k - 1 and maze[pos[0] + 1, pos[1]] == 0:  # Down
        actions.append((1, 0))
    if pos[1] > 0 and maze[pos[0], pos[1] - 1] == 0:  # Left
        actions.append((0, -1))
    if pos[1] < k - 1 and maze[pos[0], pos[1] + 1] == 0:  # Right
        actions.append((0, 1))
    return actions

def get_next_position(pos, action):
    return (pos[0] + action[0], pos[1] + action[1])



